{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Frequenz Filter Lines Superfence","text":""},{"location":"#introduction","title":"Introduction","text":"<p>A custom superfence for pymdown-extensions that can filters lines and plays nice with MkDocs.</p> <p>This is particularly useful when you want to hide some comments or some boilerplate code from the documentation for any reason.</p> <p>A typical use case is when you are testing your examples in the documentation, so you might need to add some initialization code, or importing some dependencies that are not relevant for the point you are trying to make in the documentation, but you still need the example code to work to make sure they are not inadvertedly broken.</p>"},{"location":"#quick-example","title":"Quick Example","text":"<p>When writing some documentation, and you want to show some code block, but you want to show only some lines, you can use this superfence as follows:</p> <pre><code>```text show_lines=\":2,4,7,10:12,15:\"\nThis is line 1\nThis is line 2\nThis is line 3\nThis is line 4\nThis is line 5\nThis is line 6\nThis is line 7\nThis is line 8\nThis is line 9\nThis is line 10\nThis is line 11\nThis is line 12\nThis is line 13\nThis is line 14\nThis is line 15\nThis is line 16\nThis is line 17\n```\n</code></pre> <p>This will show the following block of code in the rendered output:</p> <pre><code>This is line 1\nThis is line 2\nThis is line 4\nThis is line 7\nThis is line 10\nThis is line 11\nThis is line 12\nThis is line 15\nThis is line 16\nThis is line 17\n</code></pre> <p>See Usage for a more detailed explanation of the available options.</p>"},{"location":"#configuration","title":"Configuration","text":""},{"location":"#mkdocs","title":"MkDocs","text":"<p>To use this superfence with MkDocs, you can use something like this:</p> <pre><code>markdown_extensions:\n- pymdownx.superfences:\ncustom_fences:\n- name: \"*\"\nclass: \"highlight\"\nformat: !!python/name:frequenz.pymdownx.superfences.filter_lines.do_format\nvalidator: !!python/name:frequenz.pymdownx.superfences.filter_lines.do_validate\n</code></pre>"},{"location":"#standalone","title":"Standalone","text":"<p>To use this superfence standalone, you can use something like this:</p> <pre><code>import markdown\nfrom frequenz.pymdownx.superfences.filter_lines import do_format, do_validate\nhtml = markdown.markdown(\nmarkdown_source,\nextensions=['pymdownx.superfences'],\nextension_configs={\n\"pymdownx.superfences\": {\n\"custom_fences\": [\n{\n'name': '*',\n'class': 'highlight',\n'validator': do_validate,\n'format': do_format\n}\n]\n}\n}\n)\nprint(html)\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>See Quick Example for an example.</p> <p>The superfence supports the following options:</p>"},{"location":"#show_lines","title":"<code>show_lines</code>","text":"<p>A comma separated list of line numbers or ranges of line numbers to show.</p> <p>The line numbers are 1-based. If any line number is zero or negative, a warning is logged and the line or range are ignored.</p> <p>If <code>show_lines</code> is omitted, it defaults to showing all lines.</p>"},{"location":"#ranges","title":"Ranges","text":"<p>Ranges are inclusive and are defined as follows:</p> <ul> <li> <p>The ranges are specified as <code>start:end</code>, where <code>start</code> and <code>end</code> are the line   numbers of the first and last lines to show, respectively.</p> </li> <li> <p>If <code>start</code> is omitted, it defaults to the first line. If <code>end</code> is omitted, it   defaults to the last line.</p> </li> <li> <p>If <code>start</code> is greater than <code>end</code>, a warning is logged and the range is   ignored.</p> </li> <li> <p>If <code>start</code> is greater than the number of lines in the code block, the range   is ignored.</p> </li> <li> <p>If <code>end</code> is greater than the number of lines in the code block, it is set to   the number of lines in the code block.</p> </li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to know how to build this project and contribute to it, please check out the Contributing Guide.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Frequenz Filter Lines Superfence","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"CONTRIBUTING/#cross-arch-testing","title":"Cross-Arch Testing","text":"<p>This project has built-in support for testing across multiple architectures. Currently, our CI conducts tests on <code>arm64</code> machines using QEMU emulation. We also have the flexibility to expand this support to include additional architectures in the future.</p> <p>This project contains Dockerfiles that can be used in the CI to test the python package in non-native machine architectures, e.g., <code>arm64</code>. The Dockerfiles exist in the directory <code>.github/containers/nox-cross-arch</code>, and follow a naming scheme so that they can be easily used in build matrices in the CI, in <code>nox-cross-arch</code> job. The naming scheme is:</p> <pre><code>&lt;arch&gt;-&lt;os&gt;-python-&lt;python-version&gt;.Dockerfile\n</code></pre> <p>E.g.,</p> <pre><code>arm64-ubuntu-20.04-python-3.11.Dockerfile\n</code></pre> <p>If a Dockerfile for your desired target architecture, OS, and python version does not exist here, please add one before proceeding to add your options to the test matrix.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>pymdownx<ul> <li>superfences<ul> <li>filter_lines</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/frequenz/pymdownx/superfences/filter_lines/","title":"filter_lines","text":""},{"location":"reference/frequenz/pymdownx/superfences/filter_lines/#frequenz.pymdownx.superfences.filter_lines","title":"frequenz.pymdownx.superfences.filter_lines","text":"<p>A custom superfence for pymdown-extensions that can filters lines and plays nice with MkDocs.</p>"},{"location":"reference/frequenz/pymdownx/superfences/filter_lines/#frequenz.pymdownx.superfences.filter_lines-classes","title":"Classes","text":""},{"location":"reference/frequenz/pymdownx/superfences/filter_lines/#frequenz.pymdownx.superfences.filter_lines.Inputs","title":"frequenz.pymdownx.superfences.filter_lines.Inputs","text":"<p>             Bases: <code>TypedDict</code></p> <p>Raw input options before they are validated.</p> Source code in <code>frequenz/pymdownx/superfences/filter_lines/__init__.py</code> <pre><code>class Inputs(TypedDict):\n\"\"\"Raw input options before they are validated.\"\"\"\nshow_lines: NotRequired[str]\n\"\"\"Lines to show option.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/pymdownx/superfences/filter_lines/#frequenz.pymdownx.superfences.filter_lines.Inputs-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/pymdownx/superfences/filter_lines/#frequenz.pymdownx.superfences.filter_lines.Inputs.show_lines","title":"show_lines  <code>instance-attribute</code>","text":"<pre><code>show_lines: NotRequired[str]\n</code></pre> <p>Lines to show option.</p>"},{"location":"reference/frequenz/pymdownx/superfences/filter_lines/#frequenz.pymdownx.superfences.filter_lines.LinesRange","title":"frequenz.pymdownx.superfences.filter_lines.LinesRange  <code>dataclass</code>","text":"<p>A range of lines.</p> <p><code>start</code> and <code>end</code> are inclusive and the indices start from 1.</p> Source code in <code>frequenz/pymdownx/superfences/filter_lines/__init__.py</code> <pre><code>@dataclasses.dataclass(frozen=True, kw_only=True)\nclass LinesRange:\n\"\"\"A range of lines.\n    `start` and `end` are inclusive and the indices start from 1.\n    \"\"\"\nstart: int | None = None\n\"\"\"Start line.\n    `None` means the beginning of the file.\n    \"\"\"\nend: int | None = None\n\"\"\"End line.\n    `None` means the end of the file.\n    \"\"\"\ndef __post_init__(self) -&gt; None:\n\"\"\"Validate inputs upon creation.\"\"\"\nif self.start is None and self.end is None:\nraise ValueError(\"Cannot have both start and end as `None`\")\nif self.start is not None and self.start &lt; 1:\nraise ValueError(\"Start must be at least 1\")\nif self.end is not None and self.end &lt; 1:\nraise ValueError(\"End must be at least 1\")\nif self.start is not None and self.end is not None and self.start &gt; self.end:\nraise ValueError(\"Start must be less than or equal to end\")\ndef __contains__(self, item: int) -&gt; bool:\n\"\"\"Whether the item is inside this range.\"\"\"\nif self.start is None:\nassert self.end is not None\nreturn item &lt;= self.end\nif self.end is None:\nreturn self.start &lt;= item\nreturn self.start &lt;= item &lt;= self.end\n@classmethod\ndef parse(cls, text: str) -&gt; Self:\n\"\"\"Create from a string.\n        The string can be in the following formats:\n        - `start`\n        - `start:end`\n        - `:end`\n        - `start:`\n        where `start` and `end` are integers.\n        If `start` is empty, it is assumed to be 1.\n        If `end` is empty, it is assumed to be the end of the file.\n        If `start` appears without `:`, it is assumed to be both `start` and `end`.\n        Lines are 1-indexed.\n        Args:\n            text: String to parse.\n        Returns:\n            The created range.\n        Raises:\n            ValueError: If the string is invalid.\n        \"\"\"\nsplitted = text.split(\":\", 1)\nstripped = map(lambda s: s.strip(), splitted)\nmatch tuple(map(lambda s: s if s else None, stripped)):\ncase (None,):\nraise ValueError(\"Empty start\")\ncase () | (None, None):\nraise ValueError(\"Both start and end are empty\")\ncase (str() as start,):\nreturn cls(start=int(start), end=int(start))\ncase (str() as start, None):\nreturn cls(start=int(start))\ncase (None, str() as end):\nreturn cls(end=int(end))\ncase (str() as start, str() as end):\nreturn cls(start=int(start), end=int(end))\ncase _ as invalid:\nraise ValueError(f\"Invalid: {invalid!r}\")\ndef __str__(self) -&gt; str:\n\"\"\"Get the string representation.\"\"\"\nif self.start is None:\nassert self.end is not None\nreturn f\":{self.end}\"\nif self.end is None:\nreturn f\"{self.start}:\"\nreturn f\"{self.start}:{self.end}\"\n</code></pre>"},{"location":"reference/frequenz/pymdownx/superfences/filter_lines/#frequenz.pymdownx.superfences.filter_lines.LinesRange-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/pymdownx/superfences/filter_lines/#frequenz.pymdownx.superfences.filter_lines.LinesRange.end","title":"end  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>end: int | None = None\n</code></pre> <p>End line.</p> <p><code>None</code> means the end of the file.</p>"},{"location":"reference/frequenz/pymdownx/superfences/filter_lines/#frequenz.pymdownx.superfences.filter_lines.LinesRange.start","title":"start  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>start: int | None = None\n</code></pre> <p>Start line.</p> <p><code>None</code> means the beginning of the file.</p>"},{"location":"reference/frequenz/pymdownx/superfences/filter_lines/#frequenz.pymdownx.superfences.filter_lines.LinesRange-functions","title":"Functions","text":""},{"location":"reference/frequenz/pymdownx/superfences/filter_lines/#frequenz.pymdownx.superfences.filter_lines.LinesRange.__contains__","title":"__contains__","text":"<pre><code>__contains__(item: int) -&gt; bool\n</code></pre> <p>Whether the item is inside this range.</p> Source code in <code>frequenz/pymdownx/superfences/filter_lines/__init__.py</code> <pre><code>def __contains__(self, item: int) -&gt; bool:\n\"\"\"Whether the item is inside this range.\"\"\"\nif self.start is None:\nassert self.end is not None\nreturn item &lt;= self.end\nif self.end is None:\nreturn self.start &lt;= item\nreturn self.start &lt;= item &lt;= self.end\n</code></pre>"},{"location":"reference/frequenz/pymdownx/superfences/filter_lines/#frequenz.pymdownx.superfences.filter_lines.LinesRange.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate inputs upon creation.</p> Source code in <code>frequenz/pymdownx/superfences/filter_lines/__init__.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Validate inputs upon creation.\"\"\"\nif self.start is None and self.end is None:\nraise ValueError(\"Cannot have both start and end as `None`\")\nif self.start is not None and self.start &lt; 1:\nraise ValueError(\"Start must be at least 1\")\nif self.end is not None and self.end &lt; 1:\nraise ValueError(\"End must be at least 1\")\nif self.start is not None and self.end is not None and self.start &gt; self.end:\nraise ValueError(\"Start must be less than or equal to end\")\n</code></pre>"},{"location":"reference/frequenz/pymdownx/superfences/filter_lines/#frequenz.pymdownx.superfences.filter_lines.LinesRange.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Get the string representation.</p> Source code in <code>frequenz/pymdownx/superfences/filter_lines/__init__.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Get the string representation.\"\"\"\nif self.start is None:\nassert self.end is not None\nreturn f\":{self.end}\"\nif self.end is None:\nreturn f\"{self.start}:\"\nreturn f\"{self.start}:{self.end}\"\n</code></pre>"},{"location":"reference/frequenz/pymdownx/superfences/filter_lines/#frequenz.pymdownx.superfences.filter_lines.LinesRange.parse","title":"parse  <code>classmethod</code>","text":"<pre><code>parse(text: str) -&gt; Self\n</code></pre> <p>Create from a string.</p> <p>The string can be in the following formats:</p> <ul> <li><code>start</code></li> <li><code>start:end</code></li> <li><code>:end</code></li> <li><code>start:</code></li> </ul> <p>where <code>start</code> and <code>end</code> are integers.</p> <p>If <code>start</code> is empty, it is assumed to be 1. If <code>end</code> is empty, it is assumed to be the end of the file. If <code>start</code> appears without <code>:</code>, it is assumed to be both <code>start</code> and <code>end</code>.</p> <p>Lines are 1-indexed.</p> PARAMETER  DESCRIPTION <code>text</code> <p>String to parse.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The created range.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the string is invalid.</p> Source code in <code>frequenz/pymdownx/superfences/filter_lines/__init__.py</code> <pre><code>@classmethod\ndef parse(cls, text: str) -&gt; Self:\n\"\"\"Create from a string.\n    The string can be in the following formats:\n    - `start`\n    - `start:end`\n    - `:end`\n    - `start:`\n    where `start` and `end` are integers.\n    If `start` is empty, it is assumed to be 1.\n    If `end` is empty, it is assumed to be the end of the file.\n    If `start` appears without `:`, it is assumed to be both `start` and `end`.\n    Lines are 1-indexed.\n    Args:\n        text: String to parse.\n    Returns:\n        The created range.\n    Raises:\n        ValueError: If the string is invalid.\n    \"\"\"\nsplitted = text.split(\":\", 1)\nstripped = map(lambda s: s.strip(), splitted)\nmatch tuple(map(lambda s: s if s else None, stripped)):\ncase (None,):\nraise ValueError(\"Empty start\")\ncase () | (None, None):\nraise ValueError(\"Both start and end are empty\")\ncase (str() as start,):\nreturn cls(start=int(start), end=int(start))\ncase (str() as start, None):\nreturn cls(start=int(start))\ncase (None, str() as end):\nreturn cls(end=int(end))\ncase (str() as start, str() as end):\nreturn cls(start=int(start), end=int(end))\ncase _ as invalid:\nraise ValueError(f\"Invalid: {invalid!r}\")\n</code></pre>"},{"location":"reference/frequenz/pymdownx/superfences/filter_lines/#frequenz.pymdownx.superfences.filter_lines.LinesRanges","title":"frequenz.pymdownx.superfences.filter_lines.LinesRanges  <code>dataclass</code>","text":"<p>A set of line ranges.</p> Source code in <code>frequenz/pymdownx/superfences/filter_lines/__init__.py</code> <pre><code>@dataclasses.dataclass(frozen=True)\nclass LinesRanges:\n\"\"\"A set of line ranges.\"\"\"\nranges: Set[LinesRange]\n\"\"\"The lines ranges.\"\"\"\ndef __post_init__(self) -&gt; None:\n\"\"\"Validate.\"\"\"\nif not self.ranges:\nraise ValueError(\"Cannot have empty ranges\")\ndef __contains__(self, item: int) -&gt; bool:\n\"\"\"Whether the item is inside any of the ranges.\"\"\"\nreturn any(item in r for r in self.ranges)\n@classmethod\ndef parse(cls, text: str) -&gt; tuple[Self | None, list[ValueError]]:\n\"\"\"Create from a string.\n        The string must be a comma-separated list of ranges, where each range is in the\n        format described in\n        [`LinesRange.parse`][frequenz.pymdownx.superfences.filter_lines.LinesRange.parse].\n        If no ranges are given, `None` is returned. If any ranges are invalid, they are\n        ignored and a list of errors is returned.\n        Args:\n            text: String to parse.\n        Returns:\n            The created ranges, or `None` if no ranges are given, plus a list of errors,\n                if any.\n        \"\"\"\nranges: set[LinesRange] = set()\nerrors: list[ValueError] = []\nfor n, range_str in enumerate(text.split(\",\"), start=1):\ntry:\nlines_range = LinesRange.parse(range_str.strip())\nexcept ValueError as exc:\nerror = ValueError(f\"Range {n} ({range_str!r}) is invalid: {exc}\")\nerror.__cause__ = exc\nerrors.append(error)\ncontinue\nranges.add(lines_range)\nreturn cls(ranges) if ranges else None, errors\ndef __str__(self) -&gt; str:\n\"\"\"Get the string representation.\"\"\"\nreturn \",\".join(map(str, self.ranges))\n</code></pre>"},{"location":"reference/frequenz/pymdownx/superfences/filter_lines/#frequenz.pymdownx.superfences.filter_lines.LinesRanges-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/pymdownx/superfences/filter_lines/#frequenz.pymdownx.superfences.filter_lines.LinesRanges.ranges","title":"ranges  <code>instance-attribute</code>","text":"<pre><code>ranges: Set[LinesRange]\n</code></pre> <p>The lines ranges.</p>"},{"location":"reference/frequenz/pymdownx/superfences/filter_lines/#frequenz.pymdownx.superfences.filter_lines.LinesRanges-functions","title":"Functions","text":""},{"location":"reference/frequenz/pymdownx/superfences/filter_lines/#frequenz.pymdownx.superfences.filter_lines.LinesRanges.__contains__","title":"__contains__","text":"<pre><code>__contains__(item: int) -&gt; bool\n</code></pre> <p>Whether the item is inside any of the ranges.</p> Source code in <code>frequenz/pymdownx/superfences/filter_lines/__init__.py</code> <pre><code>def __contains__(self, item: int) -&gt; bool:\n\"\"\"Whether the item is inside any of the ranges.\"\"\"\nreturn any(item in r for r in self.ranges)\n</code></pre>"},{"location":"reference/frequenz/pymdownx/superfences/filter_lines/#frequenz.pymdownx.superfences.filter_lines.LinesRanges.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate.</p> Source code in <code>frequenz/pymdownx/superfences/filter_lines/__init__.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Validate.\"\"\"\nif not self.ranges:\nraise ValueError(\"Cannot have empty ranges\")\n</code></pre>"},{"location":"reference/frequenz/pymdownx/superfences/filter_lines/#frequenz.pymdownx.superfences.filter_lines.LinesRanges.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Get the string representation.</p> Source code in <code>frequenz/pymdownx/superfences/filter_lines/__init__.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Get the string representation.\"\"\"\nreturn \",\".join(map(str, self.ranges))\n</code></pre>"},{"location":"reference/frequenz/pymdownx/superfences/filter_lines/#frequenz.pymdownx.superfences.filter_lines.LinesRanges.parse","title":"parse  <code>classmethod</code>","text":"<pre><code>parse(text: str) -&gt; tuple[Self | None, list[ValueError]]\n</code></pre> <p>Create from a string.</p> <p>The string must be a comma-separated list of ranges, where each range is in the format described in <code>LinesRange.parse</code>.</p> <p>If no ranges are given, <code>None</code> is returned. If any ranges are invalid, they are ignored and a list of errors is returned.</p> PARAMETER  DESCRIPTION <code>text</code> <p>String to parse.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>tuple[Self | None, list[ValueError]]</code> <p>The created ranges, or <code>None</code> if no ranges are given, plus a list of errors, if any.</p> Source code in <code>frequenz/pymdownx/superfences/filter_lines/__init__.py</code> <pre><code>@classmethod\ndef parse(cls, text: str) -&gt; tuple[Self | None, list[ValueError]]:\n\"\"\"Create from a string.\n    The string must be a comma-separated list of ranges, where each range is in the\n    format described in\n    [`LinesRange.parse`][frequenz.pymdownx.superfences.filter_lines.LinesRange.parse].\n    If no ranges are given, `None` is returned. If any ranges are invalid, they are\n    ignored and a list of errors is returned.\n    Args:\n        text: String to parse.\n    Returns:\n        The created ranges, or `None` if no ranges are given, plus a list of errors,\n            if any.\n    \"\"\"\nranges: set[LinesRange] = set()\nerrors: list[ValueError] = []\nfor n, range_str in enumerate(text.split(\",\"), start=1):\ntry:\nlines_range = LinesRange.parse(range_str.strip())\nexcept ValueError as exc:\nerror = ValueError(f\"Range {n} ({range_str!r}) is invalid: {exc}\")\nerror.__cause__ = exc\nerrors.append(error)\ncontinue\nranges.add(lines_range)\nreturn cls(ranges) if ranges else None, errors\n</code></pre>"},{"location":"reference/frequenz/pymdownx/superfences/filter_lines/#frequenz.pymdownx.superfences.filter_lines.Options","title":"frequenz.pymdownx.superfences.filter_lines.Options","text":"<p>             Bases: <code>TypedDict</code></p> <p>Raw options before they are validated.</p> Source code in <code>frequenz/pymdownx/superfences/filter_lines/__init__.py</code> <pre><code>class Options(TypedDict):\n\"\"\"Raw options before they are validated.\"\"\"\nshow_lines: NotRequired[LinesRanges]\n\"\"\"Lines to show.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/pymdownx/superfences/filter_lines/#frequenz.pymdownx.superfences.filter_lines.Options-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/pymdownx/superfences/filter_lines/#frequenz.pymdownx.superfences.filter_lines.Options.show_lines","title":"show_lines  <code>instance-attribute</code>","text":"<pre><code>show_lines: NotRequired[LinesRanges]\n</code></pre> <p>Lines to show.</p>"},{"location":"reference/frequenz/pymdownx/superfences/filter_lines/#frequenz.pymdownx.superfences.filter_lines-functions","title":"Functions","text":""},{"location":"reference/frequenz/pymdownx/superfences/filter_lines/#frequenz.pymdownx.superfences.filter_lines.do_format","title":"frequenz.pymdownx.superfences.filter_lines.do_format","text":"<pre><code>do_format(\nsrc: str,\nlanguage: str,\nclass_name: str,\noptions: Options,\nmd: markdown.Markdown,\n**kwargs: Any\n) -&gt; Any\n</code></pre> <p>Filter the lines and run the default highlighter.</p> Source code in <code>frequenz/pymdownx/superfences/filter_lines/__init__.py</code> <pre><code>def do_format(\nsrc: str,\nlanguage: str,\nclass_name: str,\noptions: Options,\nmd: markdown.Markdown,\n**kwargs: Any,\n) -&gt; Any:\n\"\"\"Filter the lines and run the default highlighter.\"\"\"\n# Filter the lines to show\nif show_lines := options.get(\"show_lines\"):\nlines = []\nfor n, line in enumerate(src.splitlines(keepends=True), 1):\nif n in show_lines:\nlines.append(line)\nsrc = \"\".join(lines)\n# Run through default highlighter\nreturn md.preprocessors[\"fenced_code_block\"].highlight(\nsrc=src,\nclass_name=class_name,\nlanguage=language,\nmd=md,\noptions=options,\n**kwargs,\n)\n</code></pre>"},{"location":"reference/frequenz/pymdownx/superfences/filter_lines/#frequenz.pymdownx.superfences.filter_lines.do_validate","title":"frequenz.pymdownx.superfences.filter_lines.do_validate","text":"<pre><code>do_validate(\nlanguage: str,\ninputs: Inputs,\noptions: Options,\nattrs: dict[str, Any],\nmd: markdown.Markdown,\n) -&gt; bool\n</code></pre> <p>Validate the inputs.</p> Source code in <code>frequenz/pymdownx/superfences/filter_lines/__init__.py</code> <pre><code>def do_validate(\nlanguage: str,\ninputs: Inputs,\noptions: Options,\nattrs: dict[str, Any],\nmd: markdown.Markdown,\n) -&gt; bool:\n\"\"\"Validate the inputs.\"\"\"\n# Parse `show_lines` option\nif show_lines_option := inputs.get(\"show_lines\"):\nlines_ranges, errors = LinesRanges.parse(show_lines_option)\nfor error in errors:\n_warn(\n\"Invalid `show_lines` option in %r, some lines will not be filtered: %s\",\nshow_lines_option,\nerror,\n)\nif lines_ranges:\noptions[\"show_lines\"] = lines_ranges\n# Remove handled option from inputs\ndel inputs[\"show_lines\"]\n# Run default validator\nreturn cast(bool, highlight_validator(language, inputs, options, attrs, md))\n</code></pre>"}]}